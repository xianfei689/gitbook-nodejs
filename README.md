# NodeJS

以下是node.js官方网站的介绍：

> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。

### Node.js与V8引擎 <a id="nodejs&#x4E0E;v8&#x5F15;&#x64CE;"></a>

要了解Node.js，我们可以先要了解什么是v8引擎，可以说Node.js的诞生很大程度上归功于v8引擎的出现。

我们都知道计算机处理器机器语言，而JavaScript是一门高级语言，计算机并不能直接读懂。所以我们需要所谓的引擎（就是一个脚本语言的解释之行器）来将其转化成计算机所能理解的语言。V8引擎是由Google推出的，为其浏览器Chrome所设计的开源JavaScript引擎。得益于JIT，编译模式的改变与编译阶段的优化，JavaScript的性能得到了一个飞跃。

V8的源代码是用c++写的，除了对JavaScript性能的大幅提升，v8引擎也提供了“嵌入”的功能，使得开发者也可以在自己的c++程序中使用“嵌入”的v8引擎（所谓嵌入，我理解将V8引擎集成到别的软件系统中），从而高效地编译JavaScript，并加入c++的feature。要知道，作为一个底层得多的语言，c++可以实现的feature可要比JavaScript多得多。举例说明，JavaScript本身并没有read这么一个function。然而通过v8，我们可以将其绑定到一个用c++写的read callback上，从而通过JavaScript我们也可以直接加载文件了。于是，借助于v8种种便利的功能，Node.js诞生了。

Node.js是一项服务器技术。我们都知道客户端提出服务请求，而服务器端负责处理请求并提供服务。而对于互联网来说，在Node.js之前JavaScript是一项完全的客户端技术，被用于浏览器中实现各种动画，对DOM的操作等等。而后端，即服务端则是由PHP、Python、Ruby、Java等等语言来实现。Node.js的出现，使得前后端使用同一种语言，统一模型的梦想得以实现。

Node.js到底解决了JavaScript的什么痛点和问题？更好的组织代码，提升复用性。当然在ES6中这一点也得到了很大的提升。处理文件与数据库。与互联网进行沟通，以标准化的格式处理请求并发送回答。快速地解决如上问题。同时，Node.js还带来了许多别的后端技术所不具备，或是不完善的优点，如事件驱动，异步编程，非阻塞式io等等。JavaScript本身语言的特性，以及其的流行程度与社区活跃度给Node.js带来了各种意义上的优势。

### 长轮询与非阻塞 <a id="&#x957F;&#x8F6E;&#x8BE2;&#x4E0E;&#x975E;&#x963B;&#x585E;"></a>

浏览器给网站发请求的过程一直没怎么变过。当浏览器给网站发了请求。服务器收到了请求，然后开始搜寻被请求的资源。如果有需要，服务器还会查询一下数据库，最后把响应结果传回浏览器。不过，在传统的web服务器中（比如Apache），每一个请求都会让服务器创建一个新的进程（有的是线程，以下不再括号）来处理这个请求。

后来有了Ajax。有了Ajax，我们就不用每次都请求一个完整的新页面了，取而代之的是，每次只请求需要的部分页面信息就可以了。这显然是一个进步。但是比如你要建一个FriendFeed这样的社交网站（类似人人网那样的刷朋友新鲜事的网站），你的好友会随时的推送新的状态，然后你的新鲜事会实时自动刷新。要达成这个需求，我们需要让用户一直与服务器保持一个有效连接。目前最简单的实现方法，就是让用户和服务器之间保持长轮询（long polling）。

HTTP请求不是持续的连接，你请求一次，服务器响应一次，然后就完了。长轮训是一种利用HTTP模拟持续连接的技巧。具体来说，只要页面载入了，不管你需不需要服务器给你响应信息，你都会给服务器发一个Ajax请求。这个请求不同于一般的Ajax请求，服务器不会直接给你返回信息，而是它要等着，直到服务器觉得该给你发信息了，它才会响应（消耗服务器资源）。比如，你的好友发了一条新鲜事，服务器就会把这个新鲜事当做响应发给你的浏览器，然后你的浏览器就刷新页面了。浏览器收到响应刷新完之后，再发送一条新的请求给服务器，这个请求依然不会立即被响应。于是就开始重复以上步骤。利用这个方法，可以让浏览器始终保持等待响应的状态。

虽然以上过程依然只有非持续的Http参与，但是我们模拟出了一个看似持续的连接状态我们再看传统的服务器（比如Apache）。每次一个新用户连到你的网站上，你的服务器就得开一个连接。每个连接都需要占一个进程，这些进程大部分时间都是闲着的（比如等着你好友发新鲜事，等好友发完才给用户响应信息。或者等着数据库返回查询结果什么的）。虽然这些进程闲着，但是照样占用内存。这意味着，如果用户连接数的增长到一定规模，你服务器没准就要耗光内存直接瘫了。这种情况怎么解决？解决方法就是刚才上边说的：非阻塞和事件驱动。

这些概念在我们谈的这个情景里面其实没那么难理解。你把非阻塞的服务器想象成一个loop循环，这个loop会一直跑下去。一个新请求来了，这个loop就接了这个请求，把这个请求传给其他的进程（比如传给一个搞数据库查询的进程），然后响应一个回调（callback）。完事了这loop就接着跑，接其他的请求。这样下来，服务器就不会像之前那样傻等着数据库返回结果了。如果数据库把结果返回来了，loop就把结果传回用户的浏览器，接着继续跑。在这种方式下，你的服务器的进程就不会闲着等着。从而在理论上说，同一时刻的数据库查询数量，以及用户的请求数量就没有限制了。服务器只在用户那边有事件发生的时候才响应，这就是事件驱动。

Node.js的应用是通过javascript开发的，然后直接在Google V8引擎上跑。用了Node.js，你就不用担心用户端的请求会在服务器里跑了一段能够造成阻塞的代码了。因为javascript本身就是事件驱动的脚本语言。你回想一下，在给前端写javascript的时候，更多时候你都是在搞事件处理和回调函数。javascript本身就是给事件处理量身定制的语言。

Node.js还是处于初期阶段。如果你想开发一个基于Node.js的应用，你应该会需要写一些很底层代码。但是下一代浏览器很快就要采用WebSocket技术了，从而长轮询也会消失。在Web开发里，Node.js这种类型的技术只会变得越来越重要。

